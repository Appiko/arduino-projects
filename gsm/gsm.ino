
/**************************************************************

   This sketch connects to a website and downloads a page.
   It can be used to perform HTTP/RESTful API calls.

   For this example, you need to install ArduinoHttpClient library:
     https://github.com/arduino-libraries/ArduinoHttpClient
     or from http://librarymanager/all#ArduinoHttpClient

   TinyGSM Getting Started guide:
     https://tiny.cc/tinygsm-readme

   For more HTTP API examples, see ArduinoHttpClient library

   NOTE: This example may NOT work with the XBee because the
   HttpClient library does not empty to serial buffer fast enough
   and the buffer overflow causes the HttpClient library to stall.
   Boards with faster processors may work, 8MHz boards will not.
 **************************************************************/
#include <ip.h>

// Select your modem:
#define TINY_GSM_MODEM_SIM800

// Increase RX buffer to capture the entire response
// Chips without internal buffering (A6/A7, ESP8266, M590)
// need enough space in the buffer for the entire response
// else data will be lost (and the http library will fail).
#define TINY_GSM_RX_BUFFER 650

// See all AT commands, if wanted
//#define DUMP_AT_COMMANDS

// Define the serial console for debug prints, if needed
//#define TINY_GSM_DEBUG Serial
//#define LOGGING  // <- Logging is for the HTTP library

// Add a reception delay, if needed
//#define TINY_GSM_YIELD() { delay(1); }

// Set serial for debug console (to the Serial Monitor, default speed 115200)
#define SerialMon Serial

// Set serial for AT commands (to the module)
// Use Hardware Serial on Mega, Leonardo, Micro
#define SerialAT Serial1

// or Software Serial on Uno, Nano
//#include <SoftwareSerial.h>
//SoftwareSerial SerialAT(2, 3); // RX, TX

#define TINY_GSM_USE_GPRS true
#define TINY_GSM_USE_WIFI false

// set GSM PIN, if any
#define GSM_PIN ""

// Your GPRS credentials
// Leave empty, if missing user or pass
const char apn[]  = "bsnlnet";
const char gprsUser[] = "";
const char gprsPass[] = "";

// Server details
const char server[] = IP;
//char resource[] = "/image";
const int  port = 3200;

//const char data[] = {0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x38, 0x10, 0x02, 0x00, 0x00, 0x00, 0x77, 0x74, 0x70, 0x0A, 0x00, 0x00, 0x00, 0x04, 0x67, 0x41, 0x4D, 0x41, 0x00, 0x00, 0xB1, 0x8F, 0x0B, 0xFC, 0x61, 0x05, 0x00, 0x00, 0x00, 0x20, 0x63, 0x48, 0x52, 0x4D, 0x00, 0x00, 0x7A, 0x26, 0x00, 0x00, 0x80, 0x84, 0x00, 0x00, 0xFA, 0x00, 0x00, 0x00, 0x80, 0xE8, 0x00, 0x00, 0x75, 0x30, 0x00, 0x00, 0xEA, 0x60, 0x00, 0x00, 0x3A, 0x98, 0x00, 0x00, 0x17, 0x70, 0x9C, 0xBA, 0x51, 0x3C, 0x00, 0x00, 0x00, 0x06, 0x62, 0x4B, 0x47, 0x44, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x09, 0x58, 0xF7, 0xDC, 0x00, 0x00, 0x00, 0x07, 0x74, 0x49, 0x4D, 0x45, 0x07, 0xE3, 0x0B, 0x13, 0x07, 0x38, 0x0D, 0x05, 0x19, 0xDC, 0x2F, 0x00, 0x00, 0x00, 0xFB, 0x49, 0x44, 0x41, 0x54, 0x78, 0xDA, 0xED, 0xDC, 0xBB, 0x69, 0x03, 0x61, 0x10, 0x45, 0xE1, 0x19, 0x58, 0x81, 0x1D, 0x38, 0x51, 0xBA, 0x15, 0xB8, 0x1A, 0x97, 0x69, 0x57, 0xE4, 0x0A, 0x94, 0x2A, 0x51, 0xA2, 0xF0, 0x2A, 0x50, 0x0B, 0x07, 0x06, 0x86, 0xF3, 0x55, 0x30, 0xFC, 0xDC, 0x79, 0x6C, 0xB2, 0x9D, 0x24, 0x25, 0xCC, 0x51, 0x55, 0x75, 0xFC, 0x4D, 0x97, 0xB1, 0x47, 0x27, 0xC9, 0xE7, 0xCF, 0x74, 0x19, 0x7B, 0x74, 0x92, 0x7C, 0x3D, 0xA7, 0xCB, 0xD8, 0xE3, 0xA8, 0xAA, 0xBA, 0xFC, 0x4E, 0x97, 0xB1, 0xC7, 0xFB, 0x41, 0x9D, 0xA1, 0x98, 0x4E, 0x92, 0xF3, 0x3E, 0x5D, 0xC6, 0x1E, 0x26, 0x14, 0xE6, 0x0C, 0x85, 0x75, 0x92, 0x7C, 0xDF, 0xA6, 0xCB, 0xD8, 0xC3, 0x84, 0xC2, 0x9C, 0xA1, 0x30, 0x3F, 0x3D, 0x61, 0xB6, 0x3C, 0xCC, 0x96, 0x87, 0xBD, 0x5B, 0xDE, 0x84, 0x62, 0x4C, 0x28, 0xCC, 0x19, 0x0A, 0x73, 0xCB, 0xC3, 0x4C, 0x28, 0xCC, 0x19, 0x0A, 0x73, 0xCB, 0xC3, 0x4C, 0x28, 0xCC, 0x07, 0x85, 0xD9, 0xF2, 0x30, 0x13, 0x0A, 0xF3, 0x6C, 0x82, 0x79, 0xD8, 0xC3, 0x4C, 0x28, 0xCC, 0x84, 0xC2, 0x4C, 0x28, 0xCC, 0x2D, 0x0F, 0xF3, 0x0E, 0x85, 0x99, 0x50, 0x98, 0x0F, 0x0A, 0xB3, 0xE5, 0x61, 0x26, 0x14, 0xE6, 0xD9, 0x04, 0xF3, 0xB0, 0x87, 0x99, 0x50, 0x98, 0x33, 0x14, 0xE6, 0x96, 0x87, 0x99, 0x50, 0x98, 0x33, 0x14, 0xE6, 0x96, 0x87, 0xD9, 0xF2, 0xB0, 0x4E, 0x92, 0xFF, 0x73, 0xBA, 0x8C, 0x3D, 0x6C, 0x79, 0x98, 0x4B, 0x09, 0xD6, 0x49, 0x72, 0xBB, 0x4E, 0x97, 0xB1, 0x87, 0x87, 0x3D, 0xCC, 0x2D, 0x0F, 0xEB, 0x24, 0x79, 0x7C, 0x4C, 0x97, 0xB1, 0x87, 0x5B, 0x1E, 0xE6, 0x96, 0x87, 0x75, 0xE2, 0x8F, 0x86, 0x48, 0x2F, 0x50, 0x84, 0x4C, 0x90, 0x72, 0x10, 0x45, 0xF0, 0x00, 0x00, 0x00, 0x25, 0x74, 0x45, 0x58, 0x74, 0x64, 0x61, 0x74, 0x65, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x00, 0x32, 0x30, 0x31, 0x39, 0x2D, 0x31, 0x31, 0x2D, 0x31, 0x39, 0x54, 0x30, 0x37, 0x3A, 0x35, 0x36, 0x3A, 0x31, 0x33, 0x2B, 0x30, 0x30, 0x3A, 0x30, 0x30, 0xC0, 0x32, 0xA3, 0xD2, 0x00, 0x00, 0x00, 0x25, 0x74, 0x45, 0x58, 0x74, 0x64, 0x61, 0x74, 0x65, 0x3A, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x79, 0x00, 0x32, 0x30, 0x31, 0x39, 0x2D, 0x31, 0x31, 0x2D, 0x31, 0x39, 0x54, 0x30, 0x37, 0x3A, 0x35, 0x36, 0x3A, 0x31, 0x33, 0x2B, 0x30, 0x30, 0x3A, 0x30, 0x30, 0xB1, 0x6F, 0x1B, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82};
//const char data[] = {0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x25, 0xDB, 0x56, 0xCA, 0x00, 0x00, 0x00, 0x03, 0x50, 0x4C, 0x54, 0x45, 0xFF, 0x00, 0x00, 0x19, 0xE2, 0x09, 0x37, 0x00, 0x00, 0x00, 0x0A, 0x49, 0x44, 0x41, 0x54, 0x08, 0xD7, 0x63, 0x60, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0xE2, 0x21, 0xBC, 0x33, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82};
//const char data[] = {0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x25, 0xDB, 0x56, 0xCA, 0x00, 0x00, 0x00, 0x03, 0x50, 0x4C, 0x54, 0x45, 0xFF, 0x00, 0x00, 0x19, 0xE2, 0x09, 0x37, 0x00, 0x00, 0x00, 0x0A, 0x49, 0x44, 0x41, 0x54, 0x08, 0xD7, 0x63, 0x60, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0xE2, 0x21, 0xBC, 0x33, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82};
#include <TinyGsmClient.h>
#include <ArduinoHttpClient.h>

#ifdef DUMP_AT_COMMANDS
#include <StreamDebugger.h>
StreamDebugger debugger(SerialAT, SerialMon);
TinyGsm modem(debugger);
#else
TinyGsm modem(SerialAT);
#endif

TinyGsmClient client(modem);
HttpClient http(client, server, port);

void setup() {


  // Set console baud rate
  SerialMon.begin(115200);
  Serial2.begin(115200);

  delay(10);

  // Set your reset, enable, power pins here
  pinMode(20, OUTPUT);
  digitalWrite(20, HIGH);

  pinMode(23, OUTPUT);
  digitalWrite(23, HIGH);

  SerialMon.println("Wait...");

  // Set GSM module baud rate
  SerialAT.begin(115200);
  delay(3000);

  // Restart takes quite some time
  // To skip it, call init() instead of restart()
  SerialMon.println("Initializing modem...");
  modem.restart();
  // modem.init();



  String modemInfo = modem.getModemInfo();
  SerialMon.print("Modem: ");
  SerialMon.println(modemInfo);

  // Unlock your SIM card with a PIN
  //modem.simUnlock("1234");
  //  conn();
  //  makeReq("/alert");

}

void loop() {
  conn();
  makeReq("/alert?q=A");

  while (true) {

    if (Serial2.available() > 0) {
      char incomingByte = Serial2.read();
      int x = incomingByte;
      SerialMon.print(x);
      if (incomingByte != 10) {
        SerialMon.print("I received: ");
        SerialMon.println(incomingByte);
        String resource = "/alert?q=" + String(incomingByte);
        SerialMon.print(resource);
        makeReq(resource);
      }
    }
  }
  delay(500);
}

void disconnGPRS() {
  modem.gprsDisconnect();
  SerialMon.println(F("GPRS disconnected"));
}

void makeReq(String resource) {
  connGPRS();

  SerialMon.print(F("Performing HTTP GET request... "));
    int err = http.get(resource);
    SerialMon.print(err);
    if (err != 0) {
      SerialMon.println(F("failed to connect"));
      delay(1000);
      disconn();
      return;
    }
//  http.setTimeout(600);
//  http.beginRequest();
//  int err = http.post("/image/data.png");
//  if (err != 0) {
//    SerialMon.println(F("FAIL"));
//    delay(1000);
//    disconn();
//    return;
//  } else {
//    SerialMon.println(F("GOOD"));
//  }
//
//  //  SerialMon.println(data);
//
//  http.sendHeader(F("Content-Type"), F("image/png"));
//  http.sendHeader(F("Connection"), F("Keep-Alive"));
//  http.sendHeader(F("Keep-Alive"), F("timeout=120, max=1000"));
//  http.sendHeader(F("Content-Length"), "82");
//  http.sendHeader(F("Content-Transfer-Encoding"), F("binary"));
//
//  http.beginBody();
//  for (int i = 0; i < 82; i++) {
//    http.print(data[i]);
//  }
//  http.println("");
//  http.endRequest();

  int status = http.responseStatusCode();
  SerialMon.print(F("Response status code: "));
  SerialMon.println(status);
  if (!status || status < 0) {
    delay(1000);
    disconn();
    return;
  }

  SerialMon.println(F("Response Headers:"));
  while (http.headerAvailable()) {
    String headerName = http.readHeaderName();
    String headerValue = http.readHeaderValue();
    SerialMon.println("    " + headerName + " : " + headerValue);
  }

  int length = http.contentLength();
  if (length >= 0) {
    SerialMon.print(F("Content length is: "));
    SerialMon.println(length);
  }
  if (http.isResponseChunked()) {
    SerialMon.println(F("The response is chunked"));
  }

  String body = http.responseBody();
  SerialMon.println(F("Response:"));
  SerialMon.println(body);

  SerialMon.print(F("Body length is: "));
  SerialMon.println(body.length());

  disconn();

}
void disconn() {
  // Shutdown

  http.stop();
  SerialMon.println(F("Server disconnected"));

  disconnGPRS();

}
void conn() {
  SerialMon.print("Waiting for network...");
  if (!modem.waitForNetwork()) {
    SerialMon.println(" fail");
    delay(10000);
    return;
  }
  SerialMon.println(" OK");

  if (modem.isNetworkConnected()) {
    SerialMon.println("Network connected");
  }

}

void connGPRS() {
  SerialMon.print(F("Connecting to "));
  SerialMon.print(apn);
  if (!modem.gprsConnect(apn, gprsUser, gprsPass)) {
    SerialMon.println(" fail");
    delay(10000);
    return;
  }
  SerialMon.println(" OK");
}
